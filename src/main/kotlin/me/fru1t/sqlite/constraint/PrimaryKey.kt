package me.fru1t.sqlite.constraint

import me.fru1t.sqlite.Table
import java.util.Arrays
import kotlin.reflect.KProperty1

/**
 * Declares a [Table]'s [PrimaryKey] columns. Only a single primary key group may exist for a single
 * table. The name of the field is ignored in the creation of the table (as primary keys aren't
 * referenced directly anyway).
 *
 * Use [PrimaryKey.of] to create instances of this class.
 *
 * Example usage:
 * ```
 * data class ExampleTable(
 *     @Column(TEXT) val username: String,
 *     @Column(TEXT) val email: String
 * ) extends Table<ExampleTable>() {
 *   companion object {
 *     val PRIMARY_KEY = PrimaryKey.of(ExampleTable::username, ExampleTable::email)
 *   }
 * }
 * ```
 */
data class PrimaryKey<T : Table<T>>(val columns: Array<out KProperty1<T, *>>) {
  /**
   * Returns the SQL clause to create this [PrimaryKey] constraint from a `CREATE TABLE` statement.
   * Returns an empty string if no columns are specified for the [PrimaryKey].
   */
  fun getConstraintClause(): String {
    if (columns.isEmpty()) {
      return ""
    }

    val primaryKeyColumnText = StringBuilder()
    columns.forEachIndexed { index, column -> run {
      if (index > 0) {
        primaryKeyColumnText.append(',')
      }
      primaryKeyColumnText.append('`').append(Table.getColumnName(column)).append('`')
    }}
    return SQL_CLAUSE.format(primaryKeyColumnText.toString())
  }

  override fun equals(other: Any?): Boolean {
    // Auto-generated by IntelliJ
    if (this === other) return true
    if (javaClass != other?.javaClass) return false
    other as PrimaryKey<*>
    if (!Arrays.equals(columns, other.columns)) return false
    return true
  }

  override fun hashCode(): Int {
    return Arrays.hashCode(columns)
  }

  companion object {
    private const val SQL_CLAUSE = "PRIMARY KEY(%s)"

    /** Creates a [PrimaryKey] on [Table] ([T]) consisting of [columns]. */
    fun <T : Table<T>> of(vararg columns: KProperty1<T, *>): PrimaryKey<T> {
      return PrimaryKey(columns)
    }
  }
}
